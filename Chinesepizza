1062: 山东煎饼 
时间限制: 500 MS  内存限制: 64 MB
提交: 57  解决: 22
[提交][状态][讨论版]
题目描述
　　今天TheBeet去门口那家山东煎饼小摊买煎饼，到他付钱的时候他才发现，他的钱包里面只有一张100块。于是他需要把这张100块钱破开，但是TheBeet不喜欢硬币，另外由于某种原因，TheBeet也不喜欢20元的纸币，另外也不喜欢钱包里面有太多张纸币，所以他希望拿到尽量少的纸币数。给出摊主现有的纸币数量，求摊主要如何找零给TheBeet才能满足他的要求。
输入
　　输入的第一行是一个正整数N(1<=N<=40)，表示TheBeet买了N个山东煎饼，已知每个山东煎饼价格为2.5元。
　　接下来有6个非负整数，范围在[0, 1000]之内，分别表示摊主所拥有的50元、10元、5元、1元、5角、1角纸币的数量。
输出
　　输出一个整数，表示TheBeet最后收到的纸币数。如果无法满足要求，那就输出-1。
样例输入
2
100 100 100 100 100 100
样例输出
6
提示
最后TheBeet共收到50+10+10+10+10+5元钱。所以共6张纸币。
来源
xmu 
#include<stdio.h>
int main()
{
	int i,n,o,T=0;
	int N[6];
	float j[6]={50.0,10.0,5.0,1.0,0.5,0.1};
	scanf("%d",&n);
	scanf("%d %d %d %d %d %d",&N[0],&N[1],&N[2],&N[3],&N[4],&N[5]);
	float Y=100.0-n*2.5;
	for(i=0;i<5;i++)
	{
		o=(int)(Y/j[i]);
		if(o<=N[i])
		{
			T=T+o;
			Y=Y-o*j[i];
		}
		else
		{
			T=T+N[i];
			Y=Y-N[i]*j[i];
		}
		//printf("%d\n",(int)(Y/0.1));
		//printf("%d %d %f\n",o,T,Y);
	}
	//printf("%d",(int)(Y/0.1));
	if((int)(Y*10)<=N[i])
	    printf("%d\n",T+(int)(Y*10));
	else
	    printf("-1\n");
	return 0;
}
